### 没用前言

~~数学~~乱搞题，不知道为什么要打上线段树的 tag。

### 思路

显然 $O(nk)$ 的模拟不可行，发现约瑟夫环问题可以 $O(n)$ 求解，故尝试证明。

### 证明  

首先简化一下题意，$n$ 个人环状按 $1 \rightarrow k$ 序报数，报到 $k$ 的人噶掉，求最后剩下的人。  

我们通过**倒推**的方法证明。  

预先定义一些概念：  
幸存者称为 $svr$；  
“安全”表示一个人在本轮 $k$ 人中不会被噶；  
$pos$ 表示 $svr$ **在当前环中**的序号，从 $1$ 开始；  
$k$ 和 $n$ 的定义同题目。

倒向递推：

- 最后一轮报完，只剩 $svr$ 一人，此时总人数为 $1$，$pos = 0 \bmod 1 + 1$。
- 倒数第二轮中，剩下 $2$ 人，由于 $svr$ 是安全的，$pos = k \bmod 2 + 1$。
- 倒数第三轮中，剩下 $3$ 人，由于 $svr$ 是安全的，$pos = (k \bmod 2 + k) \bmod 3 + 1$。
- 倒数第四轮中，剩下 $4$ 人，$pos = ((k \bmod 2 + k) \bmod 3 + k) \bmod 4 + 1$。
- 依此类推，循环求解即可。

若希望得到准确数学证明，可以看下[知乎大佬的博文](https://zhuanlan.zhihu.com/p/121159246)。  

### 贴个代码

```cpp
inline int find(int n, int k)
{
    for (reg int i = 2; i <= n; ++i)
        pos = (pos + k) % i;
    return pos + 1;
}
```
